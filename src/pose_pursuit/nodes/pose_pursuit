#!/usr/bin/env python

import rospy
from geometry_msgs.msg import Pose, Twist
from tf.transformations import euler_from_quaternion
from nav_msgs.msg import Odometry
import numpy as np
import datetime

Kp_rho = 8.0
Kp_alpha = 0.0
Kp_beta = -0.0

Ki_rho = 0.0
Ki_alpha = 0.0
Ki_beta = -0.0

Kd_rho = 0.0
Kd_alpha = 0.0
Kd_beta = -0.0

velocity  = Twist()

x_current = 0
y_current = 0
theta_current = 0

x_goal = 0
y_goal = 0
theta_goal = 0

rho = 0
alpha = 0
beta = 0

ui_rho = 0

time = datetime.datetime.now().time().microsecond


e = """
An exception has occured. The node will now shutdown
"""


def move_to_pose(x_current, y_current, theta_current, x_goal, y_goal, theta_goal):

    global rho
    global alpha
    global beta
    global time
    global ui_rho

    time_delta = datetime.datetime.now().time().microsecond - time
    time = datetime.datetime.now().time().microsecond
    
    x_diff = x_goal - x_current
    y_diff = y_goal - y_current

    rho_old = rho
    rho = np.sqrt(x_diff**2 + y_diff**2)

    # Restrict alpha and beta (angle differences) to the range
    # [-pi, pi] to prevent unstable behavior e.g. difference going
    # from 0 rad to 2*pi rad with slight turn

    alpha_old = alpha
    alpha = (np.arctan2(y_diff, x_diff)- theta_current + np.pi) % (2 * np.pi) - np.pi
    beta_old = beta
    beta = (theta_goal - theta_current - alpha + np.pi) % (2 * np.pi) - np.pi

    #print(Kd_rho*((rho-rho_old)/time_delta))
    
    print("rho is:", rho )
    print("rho old is ", rho_old)
    # print("alpha is:",alpha)
    # print("beta is", beta)

    if (rho > 0.01):

        
        
        ui_rho = ui_rho + Ki_rho*rho
        velocity.linear.x = Kp_rho * rho + Kd_rho*((rho-rho_old)/time_delta) + ui_rho
        velocity.angular.z = Kp_alpha * alpha + Kd_alpha*((alpha-alpha_old)/time_delta) + Kp_beta * beta + Kd_beta*((beta-beta_old)/time_delta)

        if alpha > np.pi / 2 or alpha < -np.pi / 2:
            velocity.linear.x = -velocity.linear.x
    else:
        velocity.linear.x = 0.0
        velocity.angular.z = 0.0

def odom_callback(msg):
    global x_current
    global y_current
    global theta_current

    x_current = msg.pose.pose.position.x
    y_current = msg.pose.pose.position.y
    rot_q = (
            msg.pose.pose.orientation.x,
            msg.pose.pose.orientation.y,
            msg.pose.pose.orientation.z,
            msg.pose.pose.orientation.w)

    (roll_current, pitch_current, theta_current) = euler_from_quaternion(rot_q)

def pose_goal_callback(msg):
    global x_goal
    global y_goal
    global theta_goal

    x_goal = msg.position.x
    y_goal = msg.position.y
    rot_q = (
            msg.orientation.x,
            msg.orientation.y,
            msg.orientation.z,
            msg.orientation.w
            )

    (roll_goal, pitch_goal, theta_goal) = euler_from_quaternion(rot_q)




if __name__ == '__main__':
    
    rospy.init_node('pose_pursuit')
    pub = rospy.Publisher('cmd_vel', Twist, queue_size=10)
    odom_sub = rospy.Subscriber('odom', Odometry, odom_callback)
    pose_goal_sub = rospy.Subscriber('target_pose', Pose, pose_goal_callback)
    try:
        while not rospy.is_shutdown():
            
            move_to_pose(x_current, y_current, theta_current, x_goal, y_goal, theta_goal)
            pub.publish(velocity)
    except Exception as fail:
        print(fail)

    finally:
        velocity = Twist()
        velocity.linear.x = 0; velocity.linear.y=0; velocity.linear.z=0
        velocity.angular.x = 0; velocity.angular.y=0; velocity.angular.z=0
        pub.publish(velocity)
        print(" that flag")

    
