#!/usr/bin/env python

import rospy
from geometry_msgs.msg import Pose
import matplotlib.pyplot as plt
import numpy as np
from random import random

Kp_rho = 9
Kp_alpha = 15
Kp_beta = -3
dt = 0.01


def move_to_pose(x_current, y_current, theta_current, x_goal, y_goal, theta_goal):
    """
    rho is the distance between the robot and the goal position
    alpha is the angle to the goal relative to the heading of the robot
    beta is the angle between the robot's position and the goal position plus the goal angle
    Kp_rho*rho and Kp_alpha*alpha drive the robot along a line towards the goal
    Kp_beta*beta rotates the line so that it is parallel to the goal angle
    """

    x_diff = x_goal - x
    y_diff = y_goal - y

    rho = np.sqrt(x_diff**2 + y_diff**2)

    if rho > 0.001:

        x_diff = x_goal - x
        y_diff = y_goal - y

        # Restrict alpha and beta (angle differences) to the range
        # [-pi, pi] to prevent unstable behavior e.g. difference going
        # from 0 rad to 2*pi rad with slight turn

        alpha = (np.arctan2(y_diff, x_diff)
                 - theta + np.pi) % (2 * np.pi) - np.pi
        beta = (theta_goal - theta - alpha + np.pi) % (2 * np.pi) - np.pi

        v = Kp_rho * rho
        w = Kp_alpha * alpha + Kp_beta * beta

        if alpha > np.pi / 2 or alpha < -np.pi / 2:
            v = -v


def transformation_matrix(x, y, theta):
    return np.array([
        [np.cos(theta), -np.sin(theta), x],
        [np.sin(theta), np.cos(theta), y],
        [0, 0, 1]
    ])

def odm_callback(msg):
    global x_current
    global y_current
    global theta_current

    x = msg.pose.pose.position.x
    y = msg.pose.pose.position.y
    rot_q = msg.pose.pose.orientation
    (roll, pitch, theta) = euler_from_quaternion(rot_q.x, rot_q.y, rot_q.z, rot_q.w)

def pose_goal_callback(msg):


if __name__ == '__main__':
    
    rospy.init_node('pose_pursuit')
    pub = rospy.Publisher('cmd_vel', Twist, queue_size=10)
    odom_sub = rospy.Subscriber('odom', Pose, odom_callback)
    pose_goal_sub = rospy.Subscriber('pose_goal', Pose, pose_goal_callback)

    x = x_start
    y = y_start
    theta = theta_start

    while 1:
        move_to_pose(x_current, y_current, theta_current, x_goal, y_goal, theta_goal)

    
